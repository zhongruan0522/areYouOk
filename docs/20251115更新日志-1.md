现在的登录机制是怎样的

登录是“开关型”的：
只有当同时配置了 LOGIN_USERNAME 和 LOGIN_PASSWORD 这两个环境变量时，登录功能才真正启用；未配置时，系统行为和之前完全一样（不强制登录）。

登录影响范围：
一旦启用了登录，所有后端业务接口 /api/bills/*、/api/tokens/*、/api/auto-sync/* 都需要先登录获取一个登录 Token，前端所有页面（除了登录页本身）都会被路由守卫拦住，没登录就不让看。

凭证来源：
登录账号密码从 Docker 环境变量读取：

LOGIN_USERNAME：登录用户名
LOGIN_PASSWORD：登录密码
可选 LOGIN_JWT_SECRET：用来签名登录 Token 的密钥，不配就用默认值（只建议本地开发用）。
后端改了什么

新的登录中间件和工具（文件：backend/src/middleware/loginAuth.js）

核心几个导出：

isLoginConfigured()
判断是否配置了 LOGIN_USERNAME 和 LOGIN_PASSWORD，决定是否“开启登录模式”。

createLoginToken(username)
使用 jsonwebtoken 生成一个 JWT，默认有效期 7 天，包含 username 字段。

getLoginStatus(req)
从请求头里的 Authorization: Bearer <token> 解析并验证 Token，返回：

{
  loginRequired: boolean, // 是否启用了登录功能
  authenticated: boolean, // 当前这个请求是否已登录
  username: string | null
}
loginRequired(req, res, next)
Express 中间件：

如果没有配置登录账号（LOGIN_USERNAME / LOGIN_PASSWORD 为空），直接 next()，和以前一样不做限制。
如果配置了登录账号：
请求头没有合法 Bearer Token → 返回 401 + message: '未登录或登录已过期'
Token 验证失败 → 同样返回 401
Token 有效 → 把用户信息挂在 req.user 上并放行。
依赖：在 backend/package.json 里增加了：

"jsonwebtoken": "^9.0.2"
登录相关路由（文件：backend/src/routes/authRoutes.js）

新增 /api/auth 下的两个接口：

POST /api/auth/login
body：{ username, password }
行为：

若未配置 LOGIN_USERNAME / LOGIN_PASSWORD → 500 + “未配置登录账号，当前未启用登录功能”
用户名或密码为空 → 400
用户名/密码不匹配 → 401
成功 → 返回：
{
  "success": true,
  "message": "登录成功",
  "data": {
    "token": "xxx",   // 登录 JWT
    "username": "xxx"
  }
}
GET /api/auth/status
用于前端路由守卫判断“需不需要登录”和“当前有没有登录”：

如果没配置登录账号：
{
  "success": true,
  "data": {
    "loginRequired": false,
    "authenticated": true,
    "username": null
  }
}
如果配置了登录账号但没带或带错 Token → 返回 401：
{
  "success": false,
  "message": "未登录或登录已过期",
  "data": {
    "loginRequired": true,
    "authenticated": false,
    "username": null
  }
}
如果配置了并且 Token 有效 → 返回 success: true 且 authenticated: true。
入口文件挂中间件和路由（文件：backend/src/index.js）

现在的关键部分是：

const billRoutes = require('./routes/billRoutes')
const tokenRoutes = require('./routes/tokenRoutes')
const autoSyncRoutes = require('./routes/autoSyncRoutes')
const authRoutes = require('./routes/authRoutes')

const autoSyncService = require('./services/autoSyncService')
const { loginRequired } = require('./middleware/loginAuth')

// ...

// 登录相关接口：不要求已登录，用于获取登录状态和登录 Token
app.use('/api/auth', authRoutes)

// 业务接口：在配置了登录账号后，将统一要求登录
app.use('/api/bills', loginRequired, billRoutes)
app.use('/api/tokens', loginRequired, tokenRoutes)
app.use('/api/auto-sync', loginRequired, autoSyncRoutes)
这样保证了：

/api/auth/* 总是可访问（用来登录和探测状态）。
其它业务 API 在“开启登录模式”时必须带上登录 Token 才能访问。
未配置登录时完全兼容旧行为。
后端自测

我在后端临时加了一个 test-loginAuth.js 脚本，设置了环境变量，手动调用 createLoginToken、getLoginStatus 和 loginRequired，确认：

有 Token 时 authenticated: true
无 Token 时 authenticated: false
loginRequired 能正常调用 next()，说明 Token 校验流程通畅
之后已经把这个测试文件删掉，不会污染仓库。
前端改了什么

统一在请求里带上登录 Token（文件：frontend/src/api/index.js）

原来的 axios 实例上只有响应拦截器，现在加了请求拦截器：

从 localStorage 里取出登录 Token：
key：login_token
若存在且当前请求头还没有 Authorization，则自动注入：
Authorization: Bearer <login_token>
这样所有通过这个 api 实例发出的请求（账单、设置、自动同步等）都会自动携带登录 Token。
同时导出了两个新的 API 方法：

login(username, password) {
  return api.post('/auth/login', { username, password })
},

checkLoginStatus() {
  return api.get('/auth/status')
}
其它 기존的诸如 getBills / getStats / getAutoSyncConfig 这些方法保持原样，只是现在会自动附加登录 Token。

新增登录页面（文件：frontend/src/views/Login.vue）

路由路径：/login
UI：简单的卡片式登录表单，用 Element Plus：
输入用户名 (username)
输入密码 (password)
输入完点击“登录”
行为：
表单校验通过后调用 api.login(username, password)
成功时：
把 data.token 存到 localStorage.setItem('login_token', ...)
顺带把 username 存到 localStorage.setItem('login_username', ...) 方便之后如果你要在 UI 上展示用户名。
如果 URL 上有 ?redirect=xxx，登录成功后跳回该路径；否则默认跳到 /stats。
失败时弹出错误提示。
登录页面底下有一行提示，明确写了账号来自容器的环境变量 LOGIN_USERNAME / LOGIN_PASSWORD。

改造路由守卫（文件：frontend/src/router/index.js）

现在路由配置多了一个 Login：

import Login from '../views/Login.vue'
// ...
{
  path: '/login',
  name: 'Login',
  component: Login
}
并且 beforeEach 做了两层保护：

第一层：登录校验

先调用 api.checkLoginStatus()：

后端未开启登录 → 返回 loginRequired: false，前端不会强制登录。
已开启登录且 Token 有效 → loginRequired: true, authenticated: true。
已开启登录但未登录/Token 失效 → 抛出错误（message 类似“未登录或登录已过期”），前端视为 loginRequired: true, authenticated: false。
对 /login 路由：

若未启用登录（loginRequired === false）→ 直接重定向到 /，登录页不会露出来。
若已登录 → 重定向到 /stats。
否则正常展示登录页。
对其他路由：

若需要登录但当前未登录（loginRequired && !isLoggedIn）→ 跳转到 /login，并带上 redirect 参数：
{ path: '/login', query: { redirect: to.fullPath } }
第二层：沿用原有 Token / Onboarding 逻辑

访问 / 时：
调用 api.getToken() 看数据库是否已经保存大模型 Token：
有 Token → 存到 localStorage.api_token，然后跳 /stats
没 Token 或出错 → 跳 /onboarding
访问 /onboarding 时：
总是允许（前提是已经过登录层判断）。
访问其它带业务数据的页面（/stats、/bills、/sync、/settings）：
调用 api.getToken()：
有 Token → 放行
没 Token → 跳 /onboarding
整体顺序是：先看登没登录 → 再看配没配大模型 Token，两层都满足才放你进统计/账单等页面。

Header 显示

我没有强制在登录页隐藏顶部导航栏（App.vue 里仍然只根据 /onboarding 决定），但因为路由守卫已经严控：

未登录点菜单项也只会被带回 /login。
你要的话可以再加一条判断，让 /login 也走“onboarding 模式”，不过这不影响功能。
前端构建校验

我在 frontend 目录下跑了：

npm install
npm run build
Vite 构建成功，没有语法错误和类型错误，说明 Login.vue 和路由改动在编译层面是 OK 的。

Docker 这边怎么配置

docker-compose.yml 环境变量已经加好了：

environment:
  - NODE_ENV=production
  - PORT=7965
  - TZ=Asia/Shanghai
  - DB_PATH=/app/data/expense_bills.db
  # 登录账号配置：访问页面前需要输入的用户名和密码
  # 请根据需要修改为自己的账号密码
  - LOGIN_USERNAME=admin
  - LOGIN_PASSWORD=admin123
你只需要改成你自己的账号和密码即可，比如：

- LOGIN_USERNAME=me
- LOGIN_PASSWORD=superStrongPwd
如果你直接用 docker run，也可以这样：

docker run -d \
  --name areyouok-app \
  --restart unless-stopped \
  -p 3000:3000 \
  -v $(pwd)/data:/app/data:rw \
  -v $(pwd)/logs:/app/logs:rw \
  -e NODE_ENV=production \
  -e TZ=Asia/Shanghai \
  -e LOGIN_USERNAME=me \
  -e LOGIN_PASSWORD=superStrongPwd \
  ghcr.io/zhongruan0522/areYouOk:latest
可选的 Token 签名密钥（更安全一点）：

-e LOGIN_JWT_SECRET=some-long-random-string
不配的话会用默认值，只适合你本机玩玩，不太建议线上用默认。

你实际使用时的流程

在 docker-compose.yml 里填好 LOGIN_USERNAME / LOGIN_PASSWORD（或者 docker run 时带上 -e）。
docker-compose up -d（或相应的启动脚本）。
浏览器打开 http://localhost:3000：
若开启了登录 → 自动被路由带到 /login，先输入账号密码。
登录通过 → 如果还没配置大模型 Token，会再引导你去 Onboarding 页配置；已经配好 Token 的话就直接进 /stats。
可能的风险点和注意事项

如果你配置了 LOGIN_USERNAME / LOGIN_PASSWORD，但前端本地存的 login_token 已经过期：
所有 /api/bills 相关请求会收到 401。
路由守卫会重新把你带到 /login，重新登录即可。
如果你不想启用登录，只要把 LOGIN_USERNAME 或 LOGIN_PASSWORD 之一删掉就行，系统会自动退回原来的“无登录模式”。
现在后端 API 都受登录保护了，所以任何绕过前端直接打 /api/bills/... 的请求，没有带登录 Token 也会被拒绝。